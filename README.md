# 정규식 (Regular Expression)
## 문자열에서 원하는 값을 찾기 위해 사용.
1. 대소문자 구별
2. 띄어쓰기 구별
3. 왼쪽부터 오른쪽으로 순차적으로 검색

## 사용법
### 1. /^Hello/ => 해당 단어가 맨앞에 위치
1. **Hello** is Hello => OK!
2. huhuhu Hello is Hello => null

### 2. /Hello$/ => 해당 단어가 맨뒤에 위치
1. Hello is **Hello** => OK!
2. Hello is Hello hahaha => null

### 3. /\$12\$/ => 정규표현식에 속해 있는 특수문자를 검색하고 싶을때 이스케이프 문자(\)를 쓴다.
1. "**$12$** \-\ $25$" => OK!

### 4. /./ => 어던 문자든 하나를 검색
1. "**$**12$ \-\ $25$" => OK!
2. if. /..../ => 4개인 문자 (마지막에 4개가 되지 않을경우 선택하지 않음! / 띄어쓰기 포함)

### 5. /[oyu]/ => o,y,u 중에 일치하는 하나의 문자를 검색
1. "H**o**w do you do?" => OK!
2. if. /[dh]./ => 'd' or 'h'로 시작하는 2개의 알파벳으로 되어있는 단어를 검색
3. . "How **do** you do?" => OK!

### 6. /[a-c]/ => a~c 중에 일치하는 하나의 문자를 검색
1. "**a**bcdefghijklmnopqrstuvwxyz 0123456789" => OK!
2. /[C-Ka-d2-6]/ => C ~ K, a ~ d, 2 ~ 6 까지 중 하나의 문자를 검색

### 6. /[^cd]/ => ^(캐럿)을 [](대괄호) 안에서 사용하면 not(부정)의 의미 / c,d 가 아닌 문자를 검색
1. "cd**e**fghijklmnopqrstuvwxyz 0123456789" => OK!

### 7. (on|Fr|Tu) => on, Fr, Tu 중 일치하는 문자를 검색
1. "M**on**day Tuesday Friday" => OK!
2. /(Mon|Tues|Fri)day/ => Monday, Tuesday, Friday 중 일치하는 문자를 검색
3. "**Monday** Tuesday Friday" => OK!

## 수량자
### 1. /a*b/ => *: 앞의 문자(a)가 0 ~ 여러개 + b 인 문자를 검색
1. "**aab**c abc bc" => OK!

### 2. /b+c/ => +: 앞의 문자(b)가 1 ~ 여러개 + c 인 문자를 검색
1. "aa**bc** abc bc" => OK!

### 3. /a?c/ => ?: 앞의 문자(a)가 0 ~ 1 + c 인 문자를 검색
1. "aab**c** abc bc" => OK!

### 4. /.*/ => 어떤 문자든 0 ~ 여러개인 문자를 검색 (모두다 추출)
1. <b>"-@- *** -- \"*\" -- *** -@-"</b> => OK!

### 5. /-A*-/ => "-" + "A" 가 0 ~ 여러개 + "-"
1. "-@- *** <b>--</b> "*" -- *** -@-" => OK!

### 6. /[-@]*/ => "-" or "@" 가 0 ~ 여러개
1. "<b>-@-</b> *** -- "*" -- *** -@-" => OK!

### 7. /\*+/ => "*" 가 1 ~ 여러개 (1개 이상)
1. "-@- <b>***</b> -- "*" -- *** -@-" => OK!

### 8. /-@+-/ => "-" + "@" 가 1 ~ 여러개 + "-"
1. "<b>-@@@-</b> * ** - - "*" -- * ** -@@@-"; => OK!

### 9. /[^ ]+/ => " " 가 1 ~ 여러개가 없는 문자
1. "<b>-@@@-</b> * ** - - "*" -- * ** -@@@-"; => OK!

### 10. /[^@]@?@/ => "@" 가 아닌 것 + "@" 이 0 ~ 1 + "@" 인 문자
1. "--XX<b>-@</b>-XX<b>-@@</b>-XX<b>-@@</b>@-XX<b>-@@</b>@@-XX<b>-@@</b><b>-@@</b>-"; => OK!

### 11. /.{5}/ => 어떤 문자든 5개 ( {숫자} = 숫자 갯수 )
1. "<b>One r</b>ing to bring them all and in the darkness bind them"; => OK!

### 12. /[a-z]{3,}/ => "a ~ z" 의 문자 갯수가 3이상. 
1. "One <b>ring</b> to bring them all and in the darkness bind them"; => OK!

## 같은 의미의 수량자

### 1. {0,} === * : 0 ~ 여러개 / 같은 문법

### 2. {1,} === + : 1 ~ 여러개 / 같은 문법

### 3. {0, 1} === ? : 0 ~ 1 / 같은 문법

### 4. /r.*?/ => *? 수량자 동시 사용시 0 (?는 앞의 수량자의 최소의 덩어리를 찾는다.)

### 5. /r.+?/ => +? 수량자 동시 사용시 1 (?는 앞의 수량자의 최소의 덩어리를 찾는다.)

### 6. /r.??/ => ?? 수량자 동시 사용시 0 (?는 앞의 수량자의 최소의 덩어리를 찾는다.)

### 7. /\<div>.+?\</div>/ => \<div> 뒤에 연속된 문자들이 등장하다 처음으로 </div> 태그를 만날때까지 일치 (최소한의 덩어리를 찾는다.)
1. "**\<div>test\</div>**\<div>test2\</div>"

## 문자선택 /\w*/ === /[A-z0-9_]/
1. /\w/ 해당하는 문자 하나를 찾는다.

## 문자선택이 아니다 (반대!!) /\W*/ === /[^A-z0-9_]/

## 숫자 선택 /\d/ === /[0~9]/

## 숫자 선택 반대 /\D/ === /[^0~9]/

## \s 띄어쓰기

## \S 띄어쓰기가 아닌것

## \b. 단어에서 제일 첫번째 알파벳
1. \b.. 단어에서 1~2 번째 알파벳

## \B. 단어에서 첫번쨰 알파벳을 제외한 두번째 값 혹은 모두 

## .\b 단어에서 제일 마지막 알파벳
1. ..\b 단어에서 뒷순으로 1~2 번째 알파벳

## .\B 단어에서 제일 마지막 알파벳을 제외한 두번째 값 혹은 모두

## \A... 문장의 시작점의 3개의 문자

## ...\Z 문장의 가장 마지막 3개의 문자

## \w+(?=X) 해당 단어의 문자가 1 ~ 여러개 이고, X 라는 알파벳이 나오기 전까지 선택
1. **AAA**X---aaax---111

## AAA(?!X) AAA라는 단어 다음으로 X가 없는 AAA를 선택

참고
> 공부사이트: http://zvon.org/comp/r/tut-Regexp.html